{"version":3,"sources":["../../../src/DefaultReconnectPolicy.ts","../../../src/Errors.ts","../../../src/HttpClient.ts","../../../src/FetchHttpClient.ts","../../../src/XhrHttpClient.ts","../../../src/ITransport.ts","../../../src/DefaultHttpClient.ts","../../../src/HeaderNames.ts","../../../src/AbortController.ts","../../../src/LongPollingTransport.ts","../../../src/ServerSentEventsTransport.ts","../../../src/WebSocketTransport.ts","../../../src/HttpConnection.ts","../../../src/TextMessageFormat.ts","../../../src/HandshakeProtocol.ts","../../../src/IHubProtocol.ts","../../../src/Subject.ts","../../../src/HubConnection.ts","../../../src/JsonHubProtocol.ts","../../../src/HubConnectionBuilder.ts","../../../src/ILogger.ts","../../../src/Utils.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../../../src/Loggers.ts"],"names":["DEFAULT_RETRY_DELAYS_IN_MILLISECONDS","retryDelays","this","_retryDelays","undefined","retryContext","previousRetryCount","errorMessage","statusCode","trueProto","prototype","__proto__","Error","message","transport","errorType","innerErrors","statusText","content","url","options","send","method","logger","_logger","fetch","requireFunc","_jar","_fetchType","bind","AbortController","_abortControllerType","request","a","abortSignal","aborted","abortController","onabort","abort","error","timeoutId","timeout","msTimeout","setTimeout","log","Warning","body","cache","credentials","withCredentials","headers","mode","redirect","signal","response","clearTimeout","ok","deserializeContent","status","responseType","payload","cookies","isNode","getCookies","e","c","join","arrayBuffer","text","HttpTransportType","TransferFormat","Promise","reject","resolve","xhr","XMLHttpRequest","open","setRequestHeader","Object","keys","forEach","header","onload","responseText","onerror","ontimeout","_httpClient","getCookieString","Authorization","Cookie","_isAborted","httpClient","accessTokenFactory","_accessTokenFactory","_pollAbort","_options","_running","onreceive","onclose","transferFormat","isRequired","isIn","_url","Trace","Binary","name","value","pollOptions","_getAccessToken","token","_updateHeaderToken","pollUrl","Date","now","get","_closeError","_receiving","_poll","Information","logMessageContent","pollAborted","_raiseOnClose","data","deleteOptions","delete","logMessage","indexOf","encodeURIComponent","opened","Text","eventSource","isBrowser","isWebWorker","EventSource","onmessage","_close","onopen","_eventSource","close","webSocketConstructor","_logMessageContent","_webSocketConstructor","_headers","webSocket","replace","binaryType","_event","_webSocket","event","ErrorEvent","readyState","OPEN","_isCloseEvent","wasClean","code","reason","_stopPromiseResolver","features","_negotiateVersion","baseUrl","_resolveUrl","webSocketModule","eventSourceModule","WebSocket","_connectionState","_connectionStarted","Debug","_startInternalPromise","_startInternal","_stopPromise","_sendQueue","_stopInternal","_stopError","stop","_stopConnection","skipNegotiation","WebSockets","_constructTransport","_startTransport","negotiateResponse","redirects","_getNegotiationResponse","ProtocolVersion","accessToken","_createTransport","inherentKeepAlive","negotiateUrl","_resolveNegotiateUrl","post","JSON","parse","negotiateVersion","connectionToken","connectionId","requestedTransport","requestedTransferFormat","connectUrl","_createConnectUrl","_isITransport","transportExceptions","transports","availableTransports","negotiate","endpoint","transportOrError","_resolveTransportOrError","push","length","ServerSentEvents","LongPolling","connect","actualTransport","transportMatches","transferFormats","map","s","ex","catch","lastIndexOf","aTag","window","document","createElement","href","index","substring","_transport","_buffer","_executing","_sendBufferedData","_transportResult","_sendLoopPromise","_sendLoop","_bufferData","promise","transportResult","TransportSendQueue","_concatBuffers","arrayBuffers","totalLength","b","byteLength","reduce","result","Uint8Array","offset","item","set","buffer","_resolver","_rejecter","output","TextMessageFormat","RecordSeparator","input","messages","split","pop","RecordSeparatorCode","String","fromCharCode","MessageType","handshakeRequest","write","stringify","messageData","remainingData","binaryData","separatorIndex","responseLength","apply","Array","slice","call","textData","type","HubConnectionState","observers","next","err","observer","complete","connection","protocol","reconnectPolicy","_nextKeepAlive","_freezeEventListener","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","_protocol","_reconnectPolicy","_handshakeProtocol","_processIncomingData","_connectionClosed","_callbacks","_methods","_closedCallbacks","_reconnectingCallbacks","_reconnectedCallbacks","_invocationId","_receivedHandshakeResponse","Disconnected","_cachedPingMessage","writeMessage","Ping","Reconnecting","_startPromise","_startWithStateTransitions","Connecting","addEventListener","Connected","_stopDuringStartError","handshakePromise","_handshakeResolver","_handshakeRejecter","start","version","_sendMessage","writeHandshakeRequest","_cleanupTimeout","_resetTimeoutPeriod","_resetKeepAliveInterval","_cleanupPingTimer","startPromise","Disconnecting","_reconnectDelayHandle","_completeClose","methodName","args","promiseQueue","_replaceStreamingParams","streams","streamIds","invocationDescriptor","_createStreamInvocation","subject","cancelCallback","cancelInvocation","_createCancelInvocation","invocationId","then","_sendWithProtocol","invocationEvent","Completion","_launchStreams","sendPromise","_createInvocation","p","newMethod","toLowerCase","handlers","removeIdx","splice","callback","_processHandshakeResponse","parseMessages","Invocation","_invokeClientMethod","StreamItem","Close","allowReconnect","responseMessage","parseHandshakeResponse","getTime","_timeoutHandle","serverTimeout","_pingServerHandle","nextPing","invocationMessage","methods","target","m","arguments","_cancelCallbacksWithError","_reconnect","removeEventListener","reconnectStartTime","previousReconnectAttempts","retryError","nextRetryDelay","_getNextRetryDelay","toString","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","callbacks","key","nonblocking","streamId","subscribe","_createCompletionMessage","_createStreamItemMessage","i","argument","_isObservable","arg","StreamInvocation","id","CancelInvocation","HubConnection","instance","hubMessages","parsedMessage","_isInvocationMessage","_isStreamItemMessage","_isCompletionMessage","_assertNotEmptyString","LogLevelNameMapping","trace","debug","info","information","warn","warning","critical","Critical","none","None","logging","logLevel","mapping","parseLogLevel","transportTypeOrOptions","isNotEmpty","httpConnectionOptions","retryDelaysOrReconnectPolicy","isArray","create","LogLevel","Arg","val","match","values","Platform","self","isReactNative","getDataDetail","includeContent","detail","isArrayBuffer","view","str","num","substr","formatArrayBuffer","ArrayBuffer","constructor","sendMessage","transportName","getUserAgentHeader","createLogger","ConsoleLogger","SubjectSubscription","_subject","_observer","_","minimumLogLevel","_minLevel","out","console","msg","toISOString","userAgentHeaderName","constructUserAgent","getOsName","getRuntime","getRuntimeVersion","os","runtime","runtimeVersion","userAgent","majorAndMinor","process","platform","versions","node","getErrorString","stack","getGlobalThis","globalThis","global","Class","_cache","Map","fn","Function","TypeError","has","Wrapper","construct","getPrototypeOf","enumerable","writable","configurable","setPrototypeOf","_construct","Parent","Reflect","NullLogger","_logLevel","_message"],"mappings":"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","file":"static/js/29.05538a03.chunk.js","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IRetryPolicy, RetryContext } from \"./IRetryPolicy\";\r\n\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n\r\n/** @private */\r\nexport class DefaultReconnectPolicy implements IRetryPolicy {\r\n    private readonly _retryDelays: (number | null)[];\r\n\r\n    constructor(retryDelays?: number[]) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n\r\n    public nextRetryDelayInMilliseconds(retryContext: RetryContext): number | null {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpTransportType } from \"./ITransport\";\r\n\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The HTTP status code represented by this error. */\r\n    public statusCode: number;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage: string, statusCode: number) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occured on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occured on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occured on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occured on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occured on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occured on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message: string) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when multiple errors have occured. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The collection of errors this error is aggregating. */\r\n    public innerErrors: Error[];\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message: string, innerErrors: Error[]) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n\r\n        this.innerErrors = innerErrors;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortSignal } from \"./AbortController\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\n\r\n/** Represents an HTTP request. */\r\nexport interface HttpRequest {\r\n    /** The HTTP method to use for the request. */\r\n    method?: string;\r\n\r\n    /** The URL for the request. */\r\n    url?: string;\r\n\r\n    /** The body content for the request. May be a string or an ArrayBuffer (for binary data). */\r\n    content?: string | ArrayBuffer;\r\n\r\n    /** An object describing headers to apply to the request. */\r\n    headers?: MessageHeaders;\r\n\r\n    /** The XMLHttpRequestResponseType to apply to the request. */\r\n    responseType?: XMLHttpRequestResponseType;\r\n\r\n    /** An AbortSignal that can be monitored for cancellation. */\r\n    abortSignal?: AbortSignal;\r\n\r\n    /** The time to wait for the request to complete before throwing a TimeoutError. Measured in milliseconds. */\r\n    timeout?: number;\r\n\r\n    /** This controls whether credentials such as cookies are sent in cross-site requests. */\r\n    withCredentials?: boolean;\r\n}\r\n\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     */\r\n    constructor(statusCode: number);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code and message.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and string content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: ArrayBuffer);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string | ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string | ArrayBuffer);\r\n    constructor(\r\n        public readonly statusCode: number,\r\n        public readonly statusText?: string,\r\n        public readonly content?: string | ArrayBuffer) {\r\n    }\r\n}\r\n\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport abstract class HttpClient {\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public get(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public post(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public delete(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP request to the specified URL, returning a {@link Promise} that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {HttpRequest} request An {@link @microsoft/signalr.HttpRequest} describing the request to send.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an HttpResponse describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public abstract send(request: HttpRequest): Promise<HttpResponse>;\r\n\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    public getCookieString(url: string): string {\r\n        return \"\";\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport { CookieJar } from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly _abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly _fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly _jar?: CookieJar;\r\n\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this._fetchType = requireFunc(\"node-fetch\");\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        } else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this._abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this._fetchType(request.url!, {\r\n                body: request.content!,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\") as string;\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\nexport class XhrHttpClient extends HttpClient {\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return new Promise<HttpResponse>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n\r\n            xhr.open(request.method!, request.url!, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                        xhr.setRequestHeader(header, headers[header]);\r\n                    });\r\n            }\r\n\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                } else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n\r\n            xhr.send(request.content || \"\");\r\n        });\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport enum HttpTransportType {\r\n    /** Specifies no transport preference. */\r\n    None = 0,\r\n    /** Specifies the WebSockets transport. */\r\n    WebSockets = 1,\r\n    /** Specifies the Server-Sent Events transport. */\r\n    ServerSentEvents = 2,\r\n    /** Specifies the Long Polling transport. */\r\n    LongPolling = 4,\r\n}\r\n\r\n/** Specifies the transfer format for a connection. */\r\nexport enum TransferFormat {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    Text = 1,\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    Binary = 2,\r\n}\r\n\r\n/** An abstraction over the behavior of transports. This is designed to support the framework and not intended for use by applications. */\r\nexport interface ITransport {\r\n    connect(url: string, transferFormat: TransferFormat): Promise<void>;\r\n    send(data: any): Promise<void>;\r\n    stop(): Promise<void>;\r\n    onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    onclose: ((error?: Error) => void) | null;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    private readonly _httpClient: HttpClient;\r\n\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        } else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return this._httpClient.send(request);\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nexport abstract class HeaderNames {\r\n    static readonly Authorization = \"Authorization\";\r\n    static readonly Cookie = \"Cookie\";\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController implements AbortSignal {\r\n    private _isAborted: boolean = false;\r\n    public onabort: (() => void) | null = null;\r\n\r\n    public abort(): void {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n\r\n    get signal(): AbortSignal {\r\n        return this;\r\n    }\r\n\r\n    get aborted(): boolean {\r\n        return this._isAborted;\r\n    }\r\n}\r\n\r\n/** Represents a signal that can be monitored to determine if a request has been aborted. */\r\nexport interface AbortSignal {\r\n    /** Indicates if the request has been aborted. */\r\n    aborted: boolean;\r\n    /** Set this to a handler that will be invoked when the request is aborted. */\r\n    onabort: (() => void) | null;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient, HttpRequest } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private readonly _pollAbort: AbortController;\r\n\r\n    private _url?: string;\r\n    private _running: boolean;\r\n    private _receiving?: Promise<void>;\r\n    private _closeError?: Error;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    public get pollAborted(): boolean {\r\n        return this._pollAbort.aborted;\r\n    }\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger, options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n\r\n        this._running = false;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._url = url;\r\n\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n\r\n        const pollOptions: HttpRequest = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        const token = await this._getAccessToken();\r\n        this._updateHeaderToken(pollOptions, token);\r\n\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        } else {\r\n            this._running = true;\r\n        }\r\n\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n\r\n    private async _getAccessToken(): Promise<string | null> {\r\n        if (this._accessTokenFactory) {\r\n            return await this._accessTokenFactory();\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _updateHeaderToken(request: HttpRequest, token: string | null) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (token) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n            return;\r\n        }\r\n        if (request.headers[HeaderNames.Authorization]) {\r\n            delete request.headers[HeaderNames.Authorization];\r\n        }\r\n    }\r\n\r\n    private async _poll(url: string, pollOptions: HttpRequest): Promise<void> {\r\n        try {\r\n            while (this._running) {\r\n                // We have to get the access token on each poll, in case it changes\r\n                const token = await this._getAccessToken();\r\n                this._updateHeaderToken(pollOptions, token);\r\n\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n\r\n                        this._running = false;\r\n                    } else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    } else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent!)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        } else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    } else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        } else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url!, this._accessTokenFactory, data, this._options);\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n\r\n        try {\r\n            await this._receiving;\r\n\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n\r\n            const headers: {[k: string]: string} = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n\r\n            const deleteOptions: HttpRequest = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n            const token = await this._getAccessToken();\r\n            this._updateHeaderToken(deleteOptions, token);\r\n            await this._httpClient.delete(this._url!, deleteOptions);\r\n\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n        } finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n\r\n    private _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private _eventSource?: EventSource;\r\n    private _url?: string;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logger = logger;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent!)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e: Event) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    } else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url!, this._accessTokenFactory, data, this._options);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(e?: Error) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly _logger: ILogger;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logMessageContent: boolean;\r\n    private readonly _webSocketConstructor: WebSocketConstructor;\r\n    private readonly _httpClient: HttpClient;\r\n    private _webSocket?: WebSocket;\r\n    private _headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode) {\r\n                const headers: {[k: string]: string} = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = `${cookies}`;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            webSocket.onopen = (_event: Event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the endpoint may not be a SignalR endpoint,\"\r\n                        + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => {};\r\n            this._webSocket.onmessage = () => {};\r\n            this._webSocket.onerror = () => {};\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError } from \"./Errors\";\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: (keyof typeof TransferFormat)[];\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private _connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    // Needs to not start with _ to be available for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private transport?: ITransport;\r\n    private _startInternalPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _stopPromiseResolver: (value?: PromiseLike<void>) => void = () => {};\r\n    private _stopError?: Error;\r\n    private _accessTokenFactory?: () => string | Promise<string>;\r\n    private _sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly _negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n\r\n        let webSocketModule: any = null;\r\n        let eventSourceModule: any = null;\r\n\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n\r\n        this._httpClient = options.httpClient || new DefaultHttpClient(this._logger);\r\n        this._connectionState = ConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this._connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Connecting;\r\n\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n\r\n            return Promise.reject(new Error(message));\r\n        } else if (this._connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new Error(message));\r\n        }\r\n\r\n        this._connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this._connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Disconnecting;\r\n\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n\r\n    private async _stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n\r\n        try {\r\n            await this._startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n\r\n    private async _startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === ConnectionState.Disconnecting || this._connectionState === ConnectionState.Disconnected) {\r\n                        throw new Error(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this._connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers: {[k: string]: string} = {};\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n            }\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n\r\n    private _createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async _createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            } else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n\r\n                    if (this._connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new Error(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private _constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent!, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private _startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this._stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private _resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    } else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this._constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private _stopConnection(error?: Error): void {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Connecting) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this._connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private _resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private _buffer: any[] = [];\r\n    private _sendBufferedData: PromiseSource;\r\n    private _executing: boolean = true;\r\n    private _transportResult?: PromiseSource;\r\n    private _sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly _transport: ITransport) {\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n\r\n    private _bufferData(data: string | ArrayBuffer): void {\r\n        if (this._buffer.length && typeof(this._buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this._buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n\r\n    private async _sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this._sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this._transportResult!;\r\n            this._transportResult = undefined;\r\n\r\n            const data = typeof(this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n\r\n            this._buffer.length = 0;\r\n\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private _resolver?: () => void;\r\n    private _rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this._resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this._rejecter!(reason);\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport interface HandshakeRequestMessage {\r\n    readonly protocol: string;\r\n    readonly version: number;\r\n}\r\n\r\n/** @private */\r\nexport interface HandshakeResponseMessage {\r\n    readonly error: string;\r\n    readonly minorVersion: number;\r\n}\r\n\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    public writeHandshakeRequest(handshakeRequest: HandshakeRequestMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n\r\n    public parseHandshakeResponse(data: any): [any, HandshakeResponseMessage] {\r\n        let messageData: string;\r\n        let remainingData: any;\r\n\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        } else {\r\n            const textData: string = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage: HandshakeResponseMessage = response;\r\n\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { ILogger } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\n\r\n/** Defines the type of a Hub Message. */\r\nexport enum MessageType {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    Invocation = 1,\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    StreamItem = 2,\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    Completion = 3,\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    StreamInvocation = 4,\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    CancelInvocation = 5,\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    Ping = 6,\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    Close = 7,\r\n}\r\n\r\n/** Defines a dictionary of string keys and string values representing headers attached to a Hub message. */\r\nexport interface MessageHeaders {\r\n    /** Gets or sets the header with the specified key. */\r\n    [key: string]: string;\r\n}\r\n\r\n/** Union type of all known Hub messages. */\r\nexport type HubMessage =\r\n    InvocationMessage |\r\n    StreamInvocationMessage |\r\n    StreamItemMessage |\r\n    CompletionMessage |\r\n    CancelInvocationMessage |\r\n    PingMessage |\r\n    CloseMessage;\r\n\r\n/** Defines properties common to all Hub messages. */\r\nexport interface HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageType} value indicating the type of this message. */\r\n    readonly type: MessageType;\r\n}\r\n\r\n/** Defines properties common to all Hub messages relating to a specific invocation. */\r\nexport interface HubInvocationMessage extends HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageHeaders} dictionary containing headers attached to the message. */\r\n    readonly headers?: MessageHeaders;\r\n    /** The ID of the invocation relating to this message.\r\n     *\r\n     * This is expected to be present for {@link @microsoft/signalr.StreamInvocationMessage} and {@link @microsoft/signalr.CompletionMessage}. It may\r\n     * be 'undefined' for an {@link @microsoft/signalr.InvocationMessage} if the sender does not expect a response.\r\n     */\r\n    readonly invocationId?: string;\r\n}\r\n\r\n/** A hub message representing a non-streaming invocation. */\r\nexport interface InvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Invocation;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a streaming invocation. */\r\nexport interface StreamInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamInvocation;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a single item produced as part of a result stream. */\r\nexport interface StreamItemMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamItem;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n\r\n    /** The item produced by the server. */\r\n    readonly item?: any;\r\n}\r\n\r\n/** A hub message representing the result of an invocation. */\r\nexport interface CompletionMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Completion;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The error produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly error?: string;\r\n    /** The result produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly result?: any;\r\n}\r\n\r\n/** A hub message indicating that the sender is still active. */\r\nexport interface PingMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Ping;\r\n}\r\n\r\n/** A hub message indicating that the sender is closing the connection.\r\n *\r\n * If {@link @microsoft/signalr.CloseMessage.error} is defined, the sender is closing the connection due to an error.\r\n */\r\nexport interface CloseMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Close;\r\n    /** The error that triggered the close, if any.\r\n     *\r\n     * If this property is undefined, the connection was closed normally and without error.\r\n     */\r\n    readonly error?: string;\r\n\r\n    /** If true, clients with automatic reconnects enabled should attempt to reconnect after receiving the CloseMessage. Otherwise, they should not. */\r\n    readonly allowReconnect?: boolean;\r\n}\r\n\r\n/** A hub message sent to request that a streaming invocation be canceled. */\r\nexport interface CancelInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.CancelInvocation;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n}\r\n\r\n/** A protocol abstraction for communicating with SignalR Hubs.  */\r\nexport interface IHubProtocol {\r\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n    readonly name: string;\r\n    /** The version of the protocol. */\r\n    readonly version: number;\r\n    /** The {@link @microsoft/signalr.TransferFormat} of the protocol. */\r\n    readonly transferFormat: TransferFormat;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the `input` parameter must be a string, otherwise it must be an ArrayBuffer.\r\n     *\r\n     * @param {string | ArrayBuffer} input A string or ArrayBuffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input: string | ArrayBuffer, logger: ILogger): HubMessage[];\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string or ArrayBuffer and returns it.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the result of this method will be a string, otherwise it will be an ArrayBuffer.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string | ArrayBuffer} A string or ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message: HubMessage): string | ArrayBuffer;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { SubjectSubscription } from \"./Utils\";\r\n\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    /** @internal */\r\n    public observers: IStreamSubscriber<T>[];\r\n\r\n    /** @internal */\r\n    public cancelCallback?: () => Promise<void>;\r\n\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly _cachedPingMessage: string | ArrayBuffer;\r\n    // Needs to not start with _ for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private readonly connection: IConnection;\r\n    private readonly _logger: ILogger;\r\n    private readonly _reconnectPolicy?: IRetryPolicy;\r\n    private _protocol: IHubProtocol;\r\n    private _handshakeProtocol: HandshakeProtocol;\r\n    private _callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private _methods: { [name: string]: ((...args: any[]) => void)[] };\r\n    private _invocationId: number;\r\n\r\n    private _closedCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectingCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectedCallbacks: ((connectionId?: string) => void)[];\r\n\r\n    private _receivedHandshakeResponse: boolean;\r\n    private _handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private _handshakeRejecter!: (reason?: any) => void;\r\n    private _stopDuringStartError?: Error;\r\n\r\n    private _connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private _startPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _nextKeepAlive: number = 0;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private _reconnectDelayHandle?: any;\r\n    private _timeoutHandle?: any;\r\n    private _pingServerHandle?: any;\r\n\r\n    private _freezeEventListener = () =>\r\n    {\r\n        this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n    };\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     * The ping will happen at most as often as the server pings.\r\n     * If the server pings every 5 seconds, a value lower than 5 will ping every 5 seconds.\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this._processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this._connectionClosed(error);\r\n\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this._connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n\r\n    private async _startWithStateTransitions(): Promise<void> {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this._startInternal();\r\n\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this._protocol.transferFormat);\r\n\r\n        try {\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this._protocol.name,\r\n                version: this._protocol.version,\r\n            };\r\n\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private _stopInternal(error?: Error): Promise<void> {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise!;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue: Promise<void>;\r\n\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this._launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private _sendMessage(message: any) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private _sendWithProtocol(message: any) {\r\n        return this._sendMessage(this._protocol.writeMessage(message));\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n\r\n        this._launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this._callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => void): void {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this._methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void): void {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private _processIncomingData(data: any) {\r\n        this._cleanupTimeout();\r\n\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this._invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            } catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._resetTimeoutPeriod();\r\n    }\r\n\r\n    private _processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n\r\n        this._cleanupPingTimer();\r\n    }\r\n\r\n    private _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined)\r\n            {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        } catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private _invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methods = this._methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `A callback for the method ${invocationMessage.target.toLowerCase()} threw error '${e}'.`);\r\n            }\r\n\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this._logger.log(LogLevel.Error, message);\r\n\r\n                // We don't want to wait on the stop itself.\r\n                this._stopPromise = this._stopInternal(new Error(message));\r\n            }\r\n        } else {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n\r\n    private _connectionClosed(error?: Error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private _completeClose(error?: Error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this._startInternal();\r\n\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState as any === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this._completeClose();\r\n    }\r\n\r\n    private _getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this._reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private _cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                try {\r\n                    callback(null, error);\r\n                } catch (e) {\r\n                    this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n                }\r\n            });\r\n    }\r\n\r\n    private _cleanupPingTimer(): void {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n\r\n    private _cleanupTimeout(): void {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private _createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _launchStreams(streams: IStreamResult<any>[], promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private _replaceStreamingParams(args: any[]): [IStreamResult<any>[], string[]] {\r\n        const streams: IStreamResult<any>[] = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private _isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private _createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private _createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private _createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private _createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { CompletionMessage, HubMessage, IHubProtocol, InvocationMessage, MessageType, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\n\r\nconst JSON_HUB_PROTOCOL_NAME: string = \"json\";\r\n\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol implements IHubProtocol {\r\n\r\n    /** @inheritDoc */\r\n    public readonly name: string = JSON_HUB_PROTOCOL_NAME;\r\n    /** @inheritDoc */\r\n    public readonly version: number = 1;\r\n\r\n    /** @inheritDoc */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Text;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: string, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n\r\n        if (!input) {\r\n            return [];\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message) as HubMessage;\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n\r\n    private _isInvocationMessage(message: InvocationMessage): void {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n\r\n    private _isStreamItemMessage(message: StreamItemMessage): void {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n\r\n    private _isCompletionMessage(message: CompletionMessage): void {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n\r\n    private _assertNotEmptyString(value: any, errorMessage: string): void {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { IHubProtocol } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { HttpTransportType } from \"./ITransport\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\n\r\nconst LogLevelNameMapping: {[k: string]: LogLevel} = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\n\r\nfunction parseLogLevel(name: string): LogLevel {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    } else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    /** @internal */\r\n    public protocol?: IHubProtocol;\r\n    /** @internal */\r\n    public httpConnectionOptions?: IHttpConnectionOptions;\r\n    /** @internal */\r\n    public url?: string;\r\n    /** @internal */\r\n    public logger?: ILogger;\r\n\r\n    /** If defined, this indicates the client should automatically attempt to reconnect if the connection is lost. */\r\n    /** @internal */\r\n    public reconnectPolicy?: IRetryPolicy;\r\n\r\n    /** Configures console logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel} logLevel The minimum level of messages to log. Anything at this level, or a more severe level, will be logged.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logLevel: LogLevel): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {ILogger} logger An object implementing the {@link @microsoft/signalr.ILogger} interface, which will be used to write all log messages.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logger: ILogger): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {string} logLevel A string representing a LogLevel setting a minimum level of messages to log.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     */\r\n    public configureLogging(logLevel: string): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel | string | ILogger} logging A {@link @microsoft/signalr.LogLevel}, a string representing a LogLevel, or an object implementing the {@link @microsoft/signalr.ILogger} interface.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder;\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder {\r\n        Arg.isRequired(logging, \"logging\");\r\n\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        } else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        } else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * The transport will be selected automatically based on what the server and client support.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified HTTP-based transport to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {HttpTransportType} transportType The specific transport to use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, transportType: HttpTransportType): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {IHttpConnectionOptions} options An options object used to configure the connection.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, options: IHttpConnectionOptions): HubConnectionBuilder;\r\n    public withUrl(url: string, transportTypeOrOptions?: IHttpConnectionOptions | HttpTransportType): HubConnectionBuilder {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n\r\n        this.url = url;\r\n\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        } else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    public withHubProtocol(protocol: IHubProtocol): HubConnectionBuilder {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     * By default, the client will wait 0, 2, 10 and 30 seconds respectively before trying up to 4 reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {number[]} retryDelays An array containing the delays in milliseconds before trying each reconnect attempt.\r\n     * The length of the array represents how many failed reconnect attempts it takes before the client will stop attempting to reconnect.\r\n     */\r\n    public withAutomaticReconnect(retryDelays: number[]): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {IRetryPolicy} reconnectPolicy An {@link @microsoft/signalR.IRetryPolicy} that controls the timing and number of reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(reconnectPolicy: IRetryPolicy): HubConnectionBuilder;\r\n    public withAutomaticReconnect(retryDelaysOrReconnectPolicy?: number[] | IRetryPolicy): HubConnectionBuilder {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        } else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    public build(): HubConnection {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n\r\n        return HubConnection.create(\r\n            connection,\r\n            this.logger || NullLogger.instance,\r\n            this.protocol || new JsonHubProtocol(),\r\n            this.reconnectPolicy);\r\n    }\r\n}\r\n\r\nfunction isLogger(logger: any): logger is ILogger {\r\n    return logger.log !== undefined;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport enum LogLevel {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    Trace = 0,\r\n    /** Log level for low severity diagnostic messages. */\r\n    Debug = 1,\r\n    /** Log level for informational diagnostic messages. */\r\n    Information = 2,\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    Warning = 3,\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    Error = 4,\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    Critical = 5,\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    None = 6,\r\n}\r\n\r\n/** An abstraction that provides a sink for diagnostic messages. */\r\nexport interface ILogger {\r\n    /** Called by the framework to emit a diagnostic message.\r\n     *\r\n     * @param {LogLevel} logLevel The severity level of the message.\r\n     * @param {string} message The message.\r\n     */\r\n    log(logLevel: LogLevel, message: string): void;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\n\r\nexport const VERSION: string = \"0.0.0-DEV_BUILD\";\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    public static isNotEmpty(val: string, name: string): void {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    public static get isBrowser(): boolean {\r\n        return typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    public static get isWebWorker(): boolean {\r\n        return typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n\r\n    // react-native has a window but no document\r\n    static get isReactNative(): boolean {\r\n        return typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    public static get isNode(): boolean {\r\n        return !this.isBrowser && !this.isWebWorker && !this.isReactNative;\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string, accessTokenFactory: (() => string | Promise<string>) | undefined,\r\n                                  content: string | ArrayBuffer, options: IHttpConnectionOptions): Promise<void> {\r\n    let headers: {[k: string]: string} = {};\r\n    if (accessTokenFactory) {\r\n        const token = await accessTokenFactory();\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${token}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent!)}.`);\r\n\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers},\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel): ILogger {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log !== undefined) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private _subject: Subject<T>;\r\n    private _observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly _minLevel: LogLevel;\r\n\r\n    // Public for testing purposes.\r\n    public out: {\r\n        error(message: any): void,\r\n        warn(message: any): void,\r\n        info(message: any): void,\r\n        log(message: any): void,\r\n    };\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getUserAgentHeader(): [string, string] {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [ userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion()) ];\r\n}\r\n\r\n/** @private */\r\nexport function constructUserAgent(version: string, os: string, runtime: string, runtimeVersion: string | undefined): string {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent: string = \"Microsoft SignalR/\";\r\n\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    } else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n\r\n    userAgent += `${runtime}`;\r\n\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    } else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName(): string {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion(): string | undefined {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getRuntime(): string {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    } else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getErrorString(e: any): string {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    } else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n\r\n/** @private */\r\nexport function getGlobalThis(): unknown {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger implements ILogger {\r\n    /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\n    public static instance: ILogger = new NullLogger();\r\n\r\n    private constructor() {}\r\n\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    public log(_logLevel: LogLevel, _message: string): void {\r\n    }\r\n}\r\n"],"sourceRoot":""}