{"version":3,"sources":["libs/ReactTextareaAutosize/calcNodeHeight.js","libs/ReactTextareaAutosize/index.js","modules/adminpanel/MyBase/Types/textareafull.js"],"names":["isBrowser","window","document","isIE","documentElement","currentStyle","HIDDEN_TEXTAREA_STYLE","height","visibility","overflow","position","top","right","SIZING_STYLE","computedStyleCache","hiddenTextarea","createElement","forceHiddenStyles","node","Object","keys","forEach","key","style","setProperty","calculateNodeHeight","uiTextNode","uid","useCache","minRows","maxRows","parentNode","body","appendChild","nodeStyling","calculateNodeStyling","paddingSize","borderSize","boxSizing","sizingStyle","value","placeholder","minHeight","Infinity","maxHeight","scrollHeight","singleRowHeight","valueRowCount","Math","floor","max","min","rowCount","getComputedStyle","reduce","obj","name","getPropertyValue","width","parseFloat","nodeInfo","noop","TextareaAutosize","props","_onRef","_ref","inputRef","current","_onChange","event","_controlled","_resizeComponent","onChange","callback","process","BROWSER","nodeHeight","_uid","useCacheForDOMMeasurements","state","setState","undefined","_resizeLock","this","onHeightChange","ref","_resizeListener","addEventListener","prevProps","prevState","removeEventListener","purgeCache","React","defaultProps","BaseText","spellCheck","HelperMore","getPropsValues","defaultValueWhenNull","ev","currentTarget","onBlur","className","attrs"],"mappings":"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","file":"static/js/189.936ae5b8.chunk.js","sourcesContent":["// import isBrowser from './isBrowser.macro';\r\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\r\nconst isIE = isBrowser ? !!document.documentElement.currentStyle : false;\r\n\r\nconst HIDDEN_TEXTAREA_STYLE = {\r\n  'min-height': '0',\r\n  'max-height': 'none',\r\n  height: '0',\r\n  visibility: 'hidden',\r\n  overflow: 'hidden',\r\n  position: 'absolute',\r\n  'z-index': '-1000',\r\n  top: '0',\r\n  right: '0',\r\n};\r\n\r\nconst SIZING_STYLE = [\r\n  'letter-spacing',\r\n  'line-height',\r\n  'font-family',\r\n  'font-weight',\r\n  'font-size',\r\n  'font-style',\r\n  'tab-size',\r\n  'text-rendering',\r\n  'text-transform',\r\n  'width',\r\n  'text-indent',\r\n  'padding-top',\r\n  'padding-right',\r\n  'padding-bottom',\r\n  'padding-left',\r\n  'border-top-width',\r\n  'border-right-width',\r\n  'border-bottom-width',\r\n  'border-left-width',\r\n  'box-sizing',\r\n];\r\n\r\nlet computedStyleCache = {};\r\nconst hiddenTextarea = isBrowser && document.createElement('textarea');\r\n\r\nconst forceHiddenStyles = node => {\r\n  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(key => {\r\n    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');\r\n  });\r\n};\r\n\r\nif (isBrowser) {\r\n  forceHiddenStyles(hiddenTextarea);\r\n}\r\n\r\nexport default function calculateNodeHeight(\r\n  uiTextNode,\r\n  uid,\r\n  useCache = false,\r\n  minRows = null,\r\n  maxRows = null,\r\n) {\r\n  if (hiddenTextarea.parentNode === null) {\r\n    document.body.appendChild(hiddenTextarea);\r\n  }\r\n\r\n  // Copy all CSS properties that have an impact on the height of the content in\r\n  // the textbox\r\n  const nodeStyling = calculateNodeStyling(uiTextNode, uid, useCache);\r\n\r\n  if (nodeStyling === null) {\r\n    return null;\r\n  }\r\n\r\n  const { paddingSize, borderSize, boxSizing, sizingStyle } = nodeStyling;\r\n\r\n  // Need to have the overflow attribute to hide the scrollbar otherwise\r\n  // text-lines will not calculated properly as the shadow will technically be\r\n  // narrower for content\r\n  Object.keys(sizingStyle).forEach(key => {\r\n    hiddenTextarea.style[key] = sizingStyle[key];\r\n  });\r\n  forceHiddenStyles(hiddenTextarea);\r\n  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || 'x';\r\n\r\n  let minHeight = -Infinity;\r\n  let maxHeight = Infinity;\r\n  let height = hiddenTextarea.scrollHeight;\r\n\r\n  if (boxSizing === 'border-box') {\r\n    // border-box: add border, since height = content + padding + border\r\n    height = height + borderSize;\r\n  } else if (boxSizing === 'content-box') {\r\n    // remove padding, since height = content\r\n    height = height - paddingSize;\r\n  }\r\n\r\n  // measure height of a textarea with a single row\r\n  hiddenTextarea.value = 'x';\r\n  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;\r\n\r\n  // Stores the value's rows count rendered in `hiddenTextarea`,\r\n  // regardless if `maxRows` or `minRows` props are passed\r\n  const valueRowCount = Math.floor(height / singleRowHeight);\r\n\r\n  if (minRows !== null) {\r\n    minHeight = singleRowHeight * minRows;\r\n    if (boxSizing === 'border-box') {\r\n      minHeight = minHeight + paddingSize + borderSize;\r\n    }\r\n    height = Math.max(minHeight, height);\r\n  }\r\n\r\n  if (maxRows !== null) {\r\n    maxHeight = singleRowHeight * maxRows;\r\n    if (boxSizing === 'border-box') {\r\n      maxHeight = maxHeight + paddingSize + borderSize;\r\n    }\r\n    height = Math.min(maxHeight, height);\r\n  }\r\n\r\n  const rowCount = Math.floor(height / singleRowHeight);\r\n\r\n  return { height, minHeight, maxHeight, rowCount, valueRowCount };\r\n}\r\n\r\nfunction calculateNodeStyling(node, uid, useCache = false) {\r\n  if (useCache && computedStyleCache[uid]) {\r\n    return computedStyleCache[uid];\r\n  }\r\n\r\n  const style = window.getComputedStyle(node);\r\n\r\n  if (style === null) {\r\n    return null;\r\n  }\r\n\r\n  let sizingStyle = SIZING_STYLE.reduce((obj, name) => {\r\n    obj[name] = style.getPropertyValue(name);\r\n    return obj;\r\n  }, {});\r\n\r\n  const boxSizing = sizingStyle['box-sizing'];\r\n\r\n  // probably node is detached from DOM, can't read computed dimensions\r\n  if (boxSizing === '') {\r\n    return null;\r\n  }\r\n\r\n  // IE (Edge has already correct behaviour) returns content width as computed width\r\n  // so we need to add manually padding and border widths\r\n  if (isIE && boxSizing === 'border-box') {\r\n    sizingStyle.width =\r\n      parseFloat(sizingStyle.width) +\r\n      parseFloat(style['border-right-width']) +\r\n      parseFloat(style['border-left-width']) +\r\n      parseFloat(style['padding-right']) +\r\n      parseFloat(style['padding-left']) +\r\n      'px';\r\n  }\r\n\r\n  const paddingSize =\r\n    parseFloat(sizingStyle['padding-bottom']) +\r\n    parseFloat(sizingStyle['padding-top']);\r\n\r\n  const borderSize =\r\n    parseFloat(sizingStyle['border-bottom-width']) +\r\n    parseFloat(sizingStyle['border-top-width']);\r\n\r\n  const nodeInfo = {\r\n    sizingStyle,\r\n    paddingSize,\r\n    borderSize,\r\n    boxSizing,\r\n  };\r\n\r\n  if (useCache) {\r\n    computedStyleCache[uid] = nodeInfo;\r\n  }\r\n\r\n  return nodeInfo;\r\n}\r\n\r\nexport const purgeCache = uid => {\r\n  delete computedStyleCache[uid];\r\n};","/**\r\n * <TextareaAutosize />\r\n */\r\n\r\nimport * as React from 'react';\r\nimport * as PropTypes from 'prop-types';\r\nimport calculateNodeHeight, { purgeCache } from './calcNodeHeight';\r\n\r\nconst noop = () => {};\r\n\r\nlet uid = 0;\r\n\r\nexport default class TextareaAutosize extends React.Component {\r\n  static propTypes = {\r\n    inputRef: PropTypes.oneOfType([\r\n      PropTypes.func,\r\n      PropTypes.shape({\r\n        current: PropTypes.any,\r\n      }),\r\n    ]),\r\n    maxRows: PropTypes.number,\r\n    minRows: PropTypes.number,\r\n    onChange: PropTypes.func,\r\n    onHeightChange: PropTypes.func,\r\n    style: PropTypes.object,\r\n    useCacheForDOMMeasurements: PropTypes.bool,\r\n    value: PropTypes.string,\r\n  };\r\n\r\n  static defaultProps = {\r\n    inputRef: noop,\r\n    onChange: noop,\r\n    onHeightChange: noop,\r\n    useCacheForDOMMeasurements: false,\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      height: (props.style && props.style.height) || 0,\r\n      minHeight: -Infinity,\r\n      maxHeight: Infinity,\r\n    };\r\n\r\n    this._uid = uid++;\r\n    this._controlled = props.value !== undefined;\r\n    this._resizeLock = false;\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      inputRef: _inputRef,\r\n      maxRows: _maxRows,\r\n      minRows: _minRows,\r\n      onHeightChange: _onHeightChange,\r\n      useCacheForDOMMeasurements: _useCacheForDOMMeasurements,\r\n      ...props\r\n    } = this.props;\r\n\r\n    props.style = { ...props.style, height: this.state.height };\r\n\r\n    const maxHeight = Math.max(\r\n      props.style.maxHeight || Infinity,\r\n      this.state.maxHeight,\r\n    );\r\n\r\n    if (maxHeight < this.state.height) {\r\n      props.style.overflow = 'hidden';\r\n    }\r\n    // console.warn('textareafull render',this.props,this.props.value);\r\n    return <textarea {...props} onChange={this._onChange} ref={this._onRef} />;\r\n  }\r\n\r\n  componentDidMount() {\r\n    this._resizeComponent();\r\n    // Working around Firefox bug which runs resize listeners even when other JS is running at the same moment\r\n    // causing competing rerenders (due to setState in the listener) in React.\r\n    // More can be found here - facebook/react#6324\r\n    this._resizeListener = () => {\r\n      if (this._resizeLock) {\r\n        return;\r\n      }\r\n      this._resizeLock = true;\r\n      this._resizeComponent(() => {\r\n        this._resizeLock = false;\r\n      });\r\n    };\r\n    window.addEventListener('resize', this._resizeListener);\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    if (prevProps !== this.props) {\r\n      this._resizeComponent();\r\n    }\r\n\r\n    if (this.state.height !== prevState.height) {\r\n      this.props.onHeightChange(this.state.height, this);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener('resize', this._resizeListener);\r\n    purgeCache(this._uid);\r\n  }\r\n\r\n  _onRef = node => {\r\n    this._ref = node;\r\n    const { inputRef } = this.props;\r\n\r\n    if (typeof inputRef === 'function') {\r\n      inputRef(node);\r\n      return;\r\n    }\r\n\r\n    inputRef.current = node;\r\n  };\r\n\r\n  _onChange = event => {\r\n    if (!this._controlled) {\r\n      this._resizeComponent();\r\n    }\r\n    this.props.onChange(event, this);\r\n  };\r\n\r\n  _resizeComponent = (callback = noop) => {\r\n    if (!process.env.BROWSER && !this._ref) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    const nodeHeight = calculateNodeHeight(\r\n      this._ref,\r\n      this._uid,\r\n      this.props.useCacheForDOMMeasurements,\r\n      this.props.minRows,\r\n      this.props.maxRows,\r\n    );\r\n\r\n    if (nodeHeight === null) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    const {\r\n      height,\r\n      minHeight,\r\n      maxHeight,\r\n      rowCount,\r\n      valueRowCount,\r\n    } = nodeHeight;\r\n\r\n    this.rowCount = rowCount;\r\n    this.valueRowCount = valueRowCount;\r\n\r\n    if (\r\n      this.state.height !== height ||\r\n      this.state.minHeight !== minHeight ||\r\n      this.state.maxHeight !== maxHeight\r\n    ) {\r\n      this.setState({ height, minHeight, maxHeight }, callback);\r\n      return;\r\n    }\r\n\r\n    callback();\r\n  };\r\n}","import React from \"react\"\r\nimport TextareaAutosize from \"src/libs/ReactTextareaAutosize\"\r\nimport HelperMore from \"./_helperMore\"\r\nconst BaseText = props => {\r\n  // const more = HUtils.runFuntion(props.fnList, \"getMore\", [])\r\n  return (\r\n    <TextareaAutosize\r\n      useCacheForDOMMeasurements\r\n      spellCheck=\"false\"\r\n      {...HelperMore.getPropsValues(props, { defaultValueWhenNull: \"\" })}\r\n      onChange={ev => {\r\n        props.onChange && props.onChange(ev.currentTarget.value)\r\n      }}\r\n      onBlur={ev => {\r\n        props.onBlur && props.onBlur(ev.currentTarget.value)\r\n      }}\r\n      className={props.className}\r\n      style={props.style}\r\n      {...props.attrs}\r\n    />\r\n  )\r\n}\r\n\r\nexport default BaseText\r\n"],"sourceRoot":""}